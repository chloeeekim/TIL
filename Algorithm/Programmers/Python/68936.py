"""

쿼드압축 후 개수 세기 : https://school.programmers.co.kr/learn/courses/30/lessons/68936

0과 1로 이루어진 2^n x 2^n 크기의 2차원 정수 배열이 주어졌을 때, 쿼드 트리와 같은 방식으로 압축했을 때 배열에 최종적으로 남는 0과 1의 개수를 구하는 문제
- 쿼드 트리와 같은 방식으로 압축하는 방법은 다음과 같다
    - 압축하고자 하는 특정 영역을 S라고 정의한다
    - 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킨다
    - 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식으로 압축을 시도한다
- arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭제곱수 형태를 한다 (즉, 1, 2, 4, 8, 16, ..., 1024 중 하나이다)
    - arr의 각 행의 길이는 arr의 행의 개수와 동일하다 (즉, 정사각형 배열이다)
    - arr의 각 행에 있는 모든 값은 0 또는 1이다

Example:
- Input : arr=[[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]
- Output : [4,9]

- Input : arr=[
    [1,1,1,1,1,1,1,1],
    [0,1,1,1,1,1,1,1],
    [0,0,0,0,1,1,1,1],
    [0,1,0,0,1,1,1,1],
    [0,0,0,0,0,0,1,1],
    [0,0,0,0,0,0,0,1],
    [0,0,0,0,1,0,0,1],
    [0,0,0,0,1,1,1,1]
]
- Output : [10,15]

Note:
recursive하게 해결
solve 함수를 생성하여 (x1, y1)부터 (x2, y2)까지를 포함하는 영역에 대해서 확인
해당 영역의 값들의 합이 0이라면 모든 값이 0임을 알 수 있고,
해당 영역의 값들의 합이 (x2 - x1 + 1) ** 2와 동일하다면 모든 값이 1임을 알 수 있으므로
이 두 경우에는 0 혹은 1로 압축한다
그렇지 않은 경우 4개의 영역으로 구분하여 재귀적으로 확인

"""



def solution(arr):
    def solve(x1, y1, x2, y2):
        res = [0, 0]
        if x1 == x2:
            res[0] += 1 if arr[x1][y1] == 0 else 0
            res[1] += 1 if arr[x1][y1] == 1 else 0
        else:
            tsum = sum(sum(arr[i][y1:y2+1]) for i in range(x1, x2+1))
            if tsum == 0:
                res[0] += 1
            elif tsum == (x2 - x1 + 1) ** 2:
                res[1] += 1
            else:
                half = (x2 - x1) // 2
                div = [[x1, y1, x1 + half, y1 + half], [x1 + half + 1, y1 + half + 1, x2, y2], [x1 + half + 1, y1, x2, y1 + half], [x1, y1 + half + 1, x1 + half, y2]]
                for a, b, c, d in div:
                    temp = solve(a, b, c, d)
                    res[0] += temp[0]
                    res[1] += temp[1]
        return res

    return solve(0, 0, len(arr)-1, len(arr)-1)